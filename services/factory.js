// Generated by CoffeeScript 1.9.2
(function() {
  angular.module('metaEditor').constant('LP', {
    sc: 'Supreme Court',
    ca: 'Court of Appeal',
    fhc: 'Federal High Court',
    tat: 'Tax Appeal Tribunal',
    nic: 'National Industrial Court',
    uk: 'United Kingdom'
  }).factory('AppServe', [
    '$resource', function($resource) {
      return $resource('api/v1/legalHeads/:_id?envelope=false');
    }
  ]).factory('MergeService', [
    '$http', function($http) {
      var mService;
      mService = {
        url: 'api/v1/',
        mergeSubjectMatters: function(parent, mergeSet, court, legal_head) {
          return $http.post(this.url + 'mergeSubjectMatters?envelope=false', {
            parent: parent,
            mergeSet: mergeSet,
            court: court,
            lh: legal_head
          });
        },
        mergeIssues: function(parent, mergeSet, court, legal_head, subject_matter) {
          return $http.post(this.url + 'mergeIssues?envelope=false', {
            parent: parent,
            mergeSet: mergeSet,
            court: court,
            lh: legal_head,
            sm: subject_matter
          });
        },
        updateSubjectMatter: function(old, newSM, court, legal_head) {
          return $http.post(this.url + 'updateSubjectMatter?envelope=false', {
            old: old,
            "new": newSM,
            court: court,
            lh: legal_head
          });
        },
        updateIssue: function(old, newIssue, court, legal_head, subject_matter) {
          return $http.post(this.url + 'updateIssue?envelope=false', {
            old: old,
            "new": newIssue,
            court: court,
            lh: legal_head,
            sm: subject_matter
          });
        },
        setStandardSM: function(subject_matter, legal_head) {
          return $http.post(this.url + 'setStandard?envelope=false', {
            lh: legal_head,
            sm: subject_matter,
            subject_matter: true
          });
        },
        setStandardIssue: function(issue, subject_matter, legal_head) {
          return $http.post(this.url + 'setStandard?envelope=false', {
            iss: issue,
            lh: legal_head,
            sm: subject_matter,
            issue: true
          });
        },
        changeLegalHead: function(subject_matter, current_legal_head, new_legal_head, court) {
          return $http.post(this.url + 'changeLegalHead?envelope=false', {
            old: current_legal_head,
            "new": new_legal_head,
            sm: subject_matter,
            court: court
          });
        },
        changeSM: function(issue, current_sm, new_sm, legal_head, court) {
          return $http.post(this.url + 'changeSubjectMatter?envelope=false', {
            old: current_sm,
            "new": new_sm,
            issue: issue,
            lh: legal_head,
            court: court
          });
        },
        detachRatio: function(ratio) {
          return $http.post(this.url + 'detachRatio?envelope=false', ratio);
        },
        removeStandardSM: function(legalHead, subjectMatter) {
          return $http.post(this.url + 'removeStandard?envelope=false', {
            lh: legalHead,
            sm: subjectMatter,
            subject_matter: true
          });
        },
        removeStandardIssue: function(legalHead, subjectMatter, issue) {
          return $http.post(this.url + 'removeStandard?envelope=false', {
            lh: legalHead,
            sm: subjectMatter,
            iss: issue,
            issue: true
          });
        }
      };
      return mService;
    }
  ]).factory('AuthToken', [
    '$window', function($window) {
      return {
        get: function() {
          return $window.localStorage.getItem("LP-ME_api_key");
        },
        set: function(value) {
          return $window.localStorage.setItem("LP-ME_api_key", value);
        },
        clear: function() {
          return $window.localStorage.removeItem("LP-ME_api_key");
        }
      };
    }
  ]).factory('Session', [
    '$window', function($window) {
      return {
        get: function(key) {
          return $window.sessionStorage.getItem("__" + key);
        },
        set: function(key, value) {
          return $window.sessionStorage.setItem("__" + key, value);
        },
        clear: function(key) {
          return $window.sessionStorage.removeItem("__" + key);
        }
      };
    }
  ]).constant('AuthEvents', {
    loginSuccess: "loginSuccess",
    loginFailed: "loginFailed",
    notAuthenticated: "notAuthenticated",
    notAuthorized: "notAuthorized",
    sessionTimeout: "sessionTimeout"
  }).constant('AppConstants', {
    guest: "guest",
    authorized: "authorized"
  }).factory('AuthService', [
    '$http', 'Session', 'AuthToken', function($http, Session, AuthToken) {
      return {
        login: function(username, password) {
          return $http.post('api/v1/users/login/', {
            username: username,
            password: password
          }).then(function(response) {
            if (response.data._meta.status === 'SUCCESS') {
              AuthToken.set(response.data.records.privateKey);
            }
            Session.set("currentUser", JSON.stringify(response.data.records.user));
            return response.data.records.user;
          });
        },
        isGuest: function() {
          console.log(AuthToken.get());
          return AuthToken.get() === null;
        },
        currentUser: function() {
          return JSON.parse(Session.get("currentUser"));
        },
        logout: function() {
          Session.clear("currentUser");
          return AuthToken.clear();
        }
      };
    }
  ]).factory("AuthInterceptor", [
    '$q', '$injector', function($q, $injector) {
      return {
        request: function(config) {
          var AuthToken, token;
          AuthToken = $injector.get("AuthToken");
          token = AuthToken.get();
          config.headers = (config != null ? config.headers : void 0) || {};
          if ((token != null) && config.url.match(new RegExp('api/v1/'))) {
            config.headers.X_API_KEY = token;
          }
          return config || $q.when(config);
        },
        requestError: function(rejectReason) {
          return rejectReason;
        },
        response: function(response) {
          return response;
        },
        responseError: function(response) {
          var AuthEvents, matchesAuthenticatePath;
          AuthEvents = $injector.get('AuthEvents');
          matchesAuthenticatePath = response.config && response.config.url.match(new RegExp('api/v1/users/login/'));
          if (!matchesAuthenticatePath) {
            $injector.get('$rootScope').$broadcast({
              401: AuthEvents.notAuthenticated,
              403: AuthEvents.notAuthorized,
              409: AuthEvents.sessionTimeout
            }[response.status], response);
          }
          return $q.reject(response);
        }
      };
    }
  ]);

}).call(this);
